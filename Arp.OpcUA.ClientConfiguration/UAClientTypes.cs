// ***********************************************************************
// Assembly         : Arp.OpcUA.UseCases.eUAClient
// Author           : 7WRMZC
// Created          : 07-01-2022
//
// Last Modified By : 7WRMZC
// Last Modified On : 06-01-2022
// ***********************************************************************
// <copyright file="UAClientTypes.cs" company="Arp.OpcUA.UseCases.eUAClient">
//     Copyright (c) . All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.6.5, using .NET Client 3.0.0 template (version 2)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**
** </auto-generated>
**
** Copyright (c) 2006-2022 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.7
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.7, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://phoenixcontact.com/OpcUA/PLCnext/UAClientConfig/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.7/
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using Opc.Ua;
using System.Diagnostics;

namespace Arp.OpcUA.ClientConfiguration
{
    #region eUAClientGroupType
    /// <summary>
    /// The possible encodings for a eUAClientGroupType value.
    /// </summary>
    [DataContract(Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClientXsd)]
    public enum eUAClientGroupType
    {
        /// <summary>
        /// The subscribe
        /// </summary>
        [EnumMember(Value = "Subscribe_0")]
        Subscribe = 0,
        /// <summary>
        /// The write
        /// </summary>
        [EnumMember(Value = "Write_1")]
        Write = 1,
        /// <summary>
        /// The read
        /// </summary>
        [EnumMember(Value = "Read_2")]
        Read = 2,
    }

    #region eUAClientGroupTypeCollection Class
    /// <summary>
    /// A collection of eUAClientGroupType objects.
    /// </summary>
    [CollectionDataContract]
    public partial class eUAClientGroupTypeCollection : List<eUAClientGroupType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public eUAClientGroupTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new list can initially store.</param>
        public eUAClientGroupTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        /// <param name="collection">The collection whose elements are copied to the new list.</param>
        public eUAClientGroupTypeCollection(IEnumerable<eUAClientGroupType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator eUAClientGroupTypeCollection(eUAClientGroupType[] values)
        {
            if (values != null)
            {
                return new eUAClientGroupTypeCollection(values);
            }

            return new eUAClientGroupTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator eUAClientGroupType[](eUAClientGroupTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <returns>A new object that is a copy of this instance.</returns>
        public object Clone()
        {
            eUAClientGroupTypeCollection clone = new eUAClientGroupTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((eUAClientGroupType)Utils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion

    #endregion

    #region eUAClientConfiguration Class
    /// <summary>
    /// Class eUAClientConfiguration.
    /// Implements the <see cref="IEncodeable" />
    /// </summary>
    /// <seealso cref="IEncodeable" />
    [DataContract(Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClientXsd)]
    public partial class eUAClientConfiguration : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="eUAClientConfiguration"/> class.
        /// </summary>
        public eUAClientConfiguration()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_Name = null;
            m_NamespaceArray = new StringCollection();
            m_ServerConnections = new eUAClientServerConnectionCollection();
            m_VariableGroups = new eUAClientVariableGroupCollection();
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        /// <value>The name.</value>
        [DataMember(Name = "Name", IsRequired = false, Order = 1)]
        public string Name
        {
            get
            {
                return m_Name;
            }
            set
            {
                m_Name = value;
            }
        }
        /// <summary>
        /// Gets or sets the namespace array.
        /// </summary>
        /// <value>The namespace array.</value>
        [DataMember(Name = "NamespaceArray", IsRequired = false, Order = 2)]
        public StringCollection NamespaceArray
        {
            get
            {
                return m_NamespaceArray;
            }
            set
            {
                m_NamespaceArray = value;

                if (value == null)
                {
                    m_NamespaceArray = new StringCollection();
                }
            }
        }
        /// <summary>
        /// Gets or sets the server connections.
        /// </summary>
        /// <value>The server connections.</value>
        [DataMember(Name = "ServerConnections", IsRequired = false, Order = 3)]
        public eUAClientServerConnectionCollection ServerConnections
        {
            get
            {
                return m_ServerConnections;
            }
            set
            {
                m_ServerConnections = value;

                if (value == null)
                {
                    m_ServerConnections = new eUAClientServerConnectionCollection();
                }
            }
        }
        /// <summary>
        /// Gets or sets the variable groups.
        /// </summary>
        /// <value>The variable groups.</value>
        [DataMember(Name = "VariableGroups", IsRequired = false, Order = 4)]
        public eUAClientVariableGroupCollection VariableGroups
        {
            get
            {
                return m_VariableGroups;
            }
            set
            {
                m_VariableGroups = value;

                if (value == null)
                {
                    m_VariableGroups = new eUAClientVariableGroupCollection();
                }
            }
        }
        #endregion

        #region IEncodeable Members
        /// <inheritdoc />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.eUAClientConfiguration; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.eUAClientConfiguration_Encoding_DefaultBinary; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.eUAClientConfiguration_Encoding_DefaultXml; }
        }

        /// <inheritdoc />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.UAClientXsd);

            encoder.WriteString("Name", Name);
            encoder.WriteStringArray("NamespaceArray", NamespaceArray);
            encoder.WriteEncodeableArray("ServerConnections", ServerConnections.ToArray(), typeof(eUAClientServerConnection));
            encoder.WriteEncodeableArray("VariableGroups", VariableGroups.ToArray(), typeof(eUAClientVariableGroup));

            encoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.UAClientXsd);
            Name = decoder.ReadString("Name");
            NamespaceArray = decoder.ReadStringArray("NamespaceArray");
            ServerConnections = (eUAClientServerConnectionCollection)decoder.ReadEncodeableArray("ServerConnections", typeof(eUAClientServerConnection));
            VariableGroups = (eUAClientVariableGroupCollection)decoder.ReadEncodeableArray("VariableGroups", typeof(eUAClientVariableGroup));

            decoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            eUAClientConfiguration value = encodeable as eUAClientConfiguration;

            if (value == null)
            {
                return false;
            }
            if (!Utils.IsEqual(m_Name, value.m_Name)) return false;
            if (!Utils.IsEqual(m_NamespaceArray, value.m_NamespaceArray)) return false;
            if (!Utils.IsEqual(m_ServerConnections, value.m_ServerConnections)) return false;
            if (!Utils.IsEqual(m_VariableGroups, value.m_VariableGroups)) return false;

            return true;
        }

        /// <summary>
        /// Clones this instance.
        /// </summary>
        /// <returns>System.Object.</returns>
        public virtual object Clone()
        {
            eUAClientConfiguration clone = (eUAClientConfiguration)this.MemberwiseClone();

            clone.m_Name = (string)Utils.Clone(this.m_Name);
            clone.m_NamespaceArray = (StringCollection)Utils.Clone(this.m_NamespaceArray);
            clone.m_ServerConnections = (eUAClientServerConnectionCollection)Utils.Clone(this.m_ServerConnections);
            clone.m_VariableGroups = (eUAClientVariableGroupCollection)Utils.Clone(this.m_VariableGroups);

            return clone;
        }
        #endregion

        #region Private Fields
        private string m_Name;
        private StringCollection m_NamespaceArray;
        private eUAClientServerConnectionCollection m_ServerConnections;
        private eUAClientVariableGroupCollection m_VariableGroups;
        #endregion
    }

    #region eUAClientConfigurationCollection class
    /// <summary>
    /// A collection of eUAClientConfiguration objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfeUAClientConfiguration", Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClient, ItemName = "eUAClientConfiguration")]
    public partial class eUAClientConfigurationCollection : List<eUAClientConfiguration>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public eUAClientConfigurationCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new list can initially store.</param>
        public eUAClientConfigurationCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        /// <param name="collection">The collection whose elements are copied to the new list.</param>
        public eUAClientConfigurationCollection(IEnumerable<eUAClientConfiguration> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator eUAClientConfigurationCollection(eUAClientConfiguration[] values)
        {
            if (values != null)
            {
                return new eUAClientConfigurationCollection(values);
            }

            return new eUAClientConfigurationCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator eUAClientConfiguration[](eUAClientConfigurationCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <returns>A new object that is a copy of this instance.</returns>
        public object Clone()
        {
            eUAClientConfigurationCollection clone = new eUAClientConfigurationCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((eUAClientConfiguration)Utils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region eUAClientNodeMapping Class
    /// <summary>
    /// Class eUAClientNodeMapping.
    /// Implements the <see cref="IEncodeable" />
    /// </summary>
    /// <seealso cref="IEncodeable" />
    [DataContract(Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClientXsd)]
    public partial class eUAClientNodeMapping : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="eUAClientNodeMapping"/> class.
        /// </summary>
        public eUAClientNodeMapping()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_LocalVariable = null;
            m_RemoteVariableDescriptor = null;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the local variable.
        /// </summary>
        /// <value>The local variable.</value>
        [DataMember(Name = "LocalVariable", IsRequired = false, Order = 1)]
        public NodeId LocalVariable
        {
            get
            {
                return m_LocalVariable;
            }
            set
            {
                m_LocalVariable = value;
            }
        }
        /// <summary>
        /// Gets or sets the remote variable descriptor.
        /// </summary>
        /// <value>The remote variable descriptor.</value>
        [DataMember(Name = "RemoteVariableDescriptor", IsRequired = false, Order = 2)]
        public eUAClientRemoteVariableDescriptor RemoteVariableDescriptor
        {
            get
            {
                return m_RemoteVariableDescriptor;
            }
            set
            {
                m_RemoteVariableDescriptor = value;
            }
        }
        #endregion

        #region IEncodeable Members
        /// <inheritdoc />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.eUAClientNodeMapping; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.eUAClientNodeMapping_Encoding_DefaultBinary; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.eUAClientNodeMapping_Encoding_DefaultXml; }
        }

        /// <inheritdoc />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.UAClientXsd);

            encoder.WriteNodeId("LocalVariable", LocalVariable);
            encoder.WriteEncodeable("RemoteVariableDescriptor", RemoteVariableDescriptor, typeof(eUAClientRemoteVariableDescriptor));

            encoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.UAClientXsd);
            LocalVariable = decoder.ReadNodeId("LocalVariable");
            RemoteVariableDescriptor = (eUAClientRemoteVariableDescriptor)decoder.ReadEncodeable("RemoteVariableDescriptor", typeof(eUAClientRemoteVariableDescriptor));

            decoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            eUAClientNodeMapping value = encodeable as eUAClientNodeMapping;

            if (value == null)
            {
                return false;
            }
            if (!Utils.IsEqual(m_LocalVariable, value.m_LocalVariable)) return false;
            if (!Utils.IsEqual(m_RemoteVariableDescriptor, value.m_RemoteVariableDescriptor)) return false;

            return true;
        }

        /// <summary>
        /// Clones this instance.
        /// </summary>
        /// <returns>System.Object.</returns>
        public virtual object Clone()
        {
            eUAClientNodeMapping clone = (eUAClientNodeMapping)this.MemberwiseClone();

            clone.m_LocalVariable = (NodeId)Utils.Clone(this.m_LocalVariable);
            clone.m_RemoteVariableDescriptor = (eUAClientRemoteVariableDescriptor)Utils.Clone(this.m_RemoteVariableDescriptor);

            return clone;
        }
        #endregion

        #region Private Fields
        private NodeId m_LocalVariable;
        private eUAClientRemoteVariableDescriptor m_RemoteVariableDescriptor;
        #endregion
    }

    #region eUAClientNodeMappingCollection class
    /// <summary>
    /// A collection of eUAClientNodeMapping objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfeUAClientNodeMapping", Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClient, ItemName = "eUAClientNodeMapping")]
    public partial class eUAClientNodeMappingCollection : List<eUAClientNodeMapping>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public eUAClientNodeMappingCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new list can initially store.</param>
        public eUAClientNodeMappingCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        /// <param name="collection">The collection whose elements are copied to the new list.</param>
        public eUAClientNodeMappingCollection(IEnumerable<eUAClientNodeMapping> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator eUAClientNodeMappingCollection(eUAClientNodeMapping[] values)
        {
            if (values != null)
            {
                return new eUAClientNodeMappingCollection(values);
            }

            return new eUAClientNodeMappingCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator eUAClientNodeMapping[](eUAClientNodeMappingCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <returns>A new object that is a copy of this instance.</returns>
        public object Clone()
        {
            eUAClientNodeMappingCollection clone = new eUAClientNodeMappingCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((eUAClientNodeMapping)Utils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region eUAClientRemoteVariableDescriptor Class
    /// <summary>
    /// Class eUAClientRemoteVariableDescriptor.
    /// Implements the <see cref="IEncodeable" />
    /// </summary>
    /// <seealso cref="IEncodeable" />
    [DataContract(Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClientXsd)]
    public partial class eUAClientRemoteVariableDescriptor : IEncodeable
    {
        #region Optional Members
        /// <summary>
        /// Enum eUAClientRemoteVariableDescriptorSet
        /// </summary>
        [Flags]
        private enum eUAClientRemoteVariableDescriptorSet
        {
            /// <summary>
            /// The discovery endpoint
            /// </summary>
            DiscoveryEndpoint = 1,
            /// <summary>
            /// The server index
            /// </summary>
            ServerIndex = 2,
            /// <summary>
            /// The alias name
            /// </summary>
            AliasName = 4,
            /// <summary>
            /// The alias reference type filter
            /// </summary>
            AliasReferenceTypeFilter = 8,
            /// <summary>
            /// The relative path
            /// </summary>
            RelativePath = 16,
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="eUAClientRemoteVariableDescriptor"/> class.
        /// </summary>
        public eUAClientRemoteVariableDescriptor()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_encodingMask = 0;
            m_DiscoveryEndpoint = null;
            m_ServerIndex = null;
            m_NodeId = null;
            m_AliasName = null;
            m_AliasReferenceTypeFilter = null;
            m_RelativePath = null;
        }
        #endregion

        #region Public Properties
        [DataMember(Name = "EncodingMask", IsRequired = false, Order = 1)]
        private uint EncodingMask
        {
            get
            {
                return m_encodingMask;
            }
            set
            {
                m_encodingMask = value;
            }
        }

        /// <summary>
        /// Gets or sets the discovery endpoint.
        /// </summary>
        /// <value>The discovery endpoint.</value>
        [DataMember(Name = "DiscoveryEndpoint", IsRequired = false, Order = 2)]
        public string DiscoveryEndpoint
        {
            get
            {
                return m_DiscoveryEndpoint;
            }
            set
            {
                m_DiscoveryEndpoint = value;
                m_encodingMask |= (uint)eUAClientRemoteVariableDescriptorSet.DiscoveryEndpoint;
            }
        }
        /// <summary>
        /// Gets or sets the index of the server.
        /// </summary>
        /// <value>The index of the server.</value>
        [DataMember(Name = "ServerIndex", IsRequired = false, Order = 3)]
        public short? ServerIndex
        {
            get
            {
                return m_ServerIndex;
            }
            set
            {
                m_ServerIndex = value;
                m_encodingMask |= (uint)eUAClientRemoteVariableDescriptorSet.ServerIndex;
            }
        }
        /// <summary>
        /// Gets or sets the node identifier.
        /// </summary>
        /// <value>The node identifier.</value>
        [DataMember(Name = "NodeId", IsRequired = false, Order = 4)]
        public NodeId NodeId
        {
            get
            {
                return m_NodeId;
            }
            set
            {
                m_NodeId = value;
            }
        }
        /// <summary>
        /// Gets or sets the name of the alias.
        /// </summary>
        /// <value>The name of the alias.</value>
        [DataMember(Name = "AliasName", IsRequired = false, Order = 5)]
        public string AliasName
        {
            get
            {
                return m_AliasName;
            }
            set
            {
                m_AliasName = value;
                m_encodingMask |= (uint)eUAClientRemoteVariableDescriptorSet.AliasName;
            }
        }
        /// <summary>
        /// Gets or sets the alias reference type filter.
        /// </summary>
        /// <value>The alias reference type filter.</value>
        [DataMember(Name = "AliasReferenceTypeFilter", IsRequired = false, Order = 6)]
        public NodeId AliasReferenceTypeFilter
        {
            get
            {
                return m_AliasReferenceTypeFilter;
            }
            set
            {
                m_AliasReferenceTypeFilter = value;
                m_encodingMask |= (uint)eUAClientRemoteVariableDescriptorSet.AliasReferenceTypeFilter;
            }
        }
        /// <summary>
        /// Gets or sets the relative path.
        /// </summary>
        /// <value>The relative path.</value>
        [DataMember(Name = "RelativePath", IsRequired = false, Order = 7)]
        public RelativePathElementCollection RelativePath
        {
            get
            {
                return m_RelativePath;
            }
            set
            {
                m_RelativePath = value;

                if (value == null)
                {
                    m_RelativePath = new RelativePathElementCollection();
                }
                m_encodingMask |= (uint)eUAClientRemoteVariableDescriptorSet.RelativePath;
            }
        }

        /// <summary>
        /// Determines whether [is discovery endpoint set].
        /// </summary>
        /// <returns><c>true</c> if [is discovery endpoint set]; otherwise, <c>false</c>.</returns>
        public bool IsDiscoveryEndpointSet()
        {
            return (m_encodingMask & (uint)eUAClientRemoteVariableDescriptorSet.DiscoveryEndpoint) != 0;
        }

        /// <summary>
        /// Unsets the discovery endpoint.
        /// </summary>
        public void UnsetDiscoveryEndpoint()
        {
            m_encodingMask &= (~((uint)eUAClientRemoteVariableDescriptorSet.DiscoveryEndpoint));
            m_DiscoveryEndpoint = null;
        }

        /// <summary>
        /// Determines whether [is server index set].
        /// </summary>
        /// <returns><c>true</c> if [is server index set]; otherwise, <c>false</c>.</returns>
        public bool IsServerIndexSet()
        {
            return (m_encodingMask & (uint)eUAClientRemoteVariableDescriptorSet.ServerIndex) != 0;
        }

        /// <summary>
        /// Unsets the index of the server.
        /// </summary>
        public void UnsetServerIndex()
        {
            m_encodingMask &= (~((uint)eUAClientRemoteVariableDescriptorSet.ServerIndex));
            m_ServerIndex = null;
        }

        /// <summary>
        /// Determines whether [is alias name set].
        /// </summary>
        /// <returns><c>true</c> if [is alias name set]; otherwise, <c>false</c>.</returns>
        public bool IsAliasNameSet()
        {
            return (m_encodingMask & (uint)eUAClientRemoteVariableDescriptorSet.AliasName) != 0;
        }

        /// <summary>
        /// Unsets the name of the alias.
        /// </summary>
        public void UnsetAliasName()
        {
            m_encodingMask &= (~((uint)eUAClientRemoteVariableDescriptorSet.AliasName));
            m_AliasName = null;
        }

        /// <summary>
        /// Determines whether [is alias reference type filter set].
        /// </summary>
        /// <returns><c>true</c> if [is alias reference type filter set]; otherwise, <c>false</c>.</returns>
        public bool IsAliasReferenceTypeFilterSet()
        {
            return (m_encodingMask & (uint)eUAClientRemoteVariableDescriptorSet.AliasReferenceTypeFilter) != 0;
        }

        /// <summary>
        /// Unsets the alias reference type filter.
        /// </summary>
        public void UnsetAliasReferenceTypeFilter()
        {
            m_encodingMask &= (~((uint)eUAClientRemoteVariableDescriptorSet.AliasReferenceTypeFilter));
            m_AliasReferenceTypeFilter = null;
        }

        /// <summary>
        /// Determines whether [is relative path set].
        /// </summary>
        /// <returns><c>true</c> if [is relative path set]; otherwise, <c>false</c>.</returns>
        public bool IsRelativePathSet()
        {
            return (m_encodingMask & (uint)eUAClientRemoteVariableDescriptorSet.RelativePath) != 0;
        }

        /// <summary>
        /// Unsets the relative path.
        /// </summary>
        public void UnsetRelativePath()
        {
            m_encodingMask &= (~((uint)eUAClientRemoteVariableDescriptorSet.RelativePath));
            m_RelativePath = null;
        }
        #endregion

        #region IEncodeable Members
        /// <inheritdoc />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.eUAClientRemoteVariableDescriptor; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.eUAClientRemoteVariableDescriptor_Encoding_DefaultBinary; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.eUAClientRemoteVariableDescriptor_Encoding_DefaultXml; }
        }

        /// <inheritdoc />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.UAClientXsd);

            encoder.WriteUInt32("EncodingMask", (uint)m_encodingMask);

            if (IsDiscoveryEndpointSet())
            {
                encoder.WriteString("DiscoveryEndpoint", DiscoveryEndpoint);
            }
            if (IsServerIndexSet())
            {
                encoder.WriteInt16("ServerIndex", ServerIndex.Value);
            }
            encoder.WriteNodeId("NodeId", NodeId);
            if (IsAliasNameSet())
            {
                encoder.WriteString("AliasName", AliasName);
            }
            if (IsAliasReferenceTypeFilterSet())
            {
                encoder.WriteNodeId("AliasReferenceTypeFilter", AliasReferenceTypeFilter);
            }
            if (IsRelativePathSet())
            {
                encoder.WriteEncodeableArray("RelativePath", RelativePath.ToArray(), typeof(RelativePathElement));
            }

            encoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.UAClientXsd);

            m_encodingMask = decoder.ReadUInt32("EncodingMask");

            if (IsDiscoveryEndpointSet())
            {
                DiscoveryEndpoint = decoder.ReadString("DiscoveryEndpoint");
            }
            if (IsServerIndexSet())
            {
                ServerIndex = decoder.ReadInt16("ServerIndex");
            }
            NodeId = decoder.ReadNodeId("NodeId");
            if (IsAliasNameSet())
            {
                AliasName = decoder.ReadString("AliasName");
            }
            if (IsAliasReferenceTypeFilterSet())
            {
                AliasReferenceTypeFilter = decoder.ReadNodeId("AliasReferenceTypeFilter");
            }
            if (IsRelativePathSet())
            {
                RelativePath = (RelativePathElementCollection)decoder.ReadEncodeableArray("RelativePath", typeof(RelativePathElement));
            }

            decoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            eUAClientRemoteVariableDescriptor value = encodeable as eUAClientRemoteVariableDescriptor;

            if (value == null)
            {
                return false;
            }
            if (m_encodingMask != value.m_encodingMask) return false;
            if (IsDiscoveryEndpointSet())
            {
                if (!Utils.IsEqual(m_DiscoveryEndpoint, value.m_DiscoveryEndpoint)) return false;
            }
            if (IsServerIndexSet())
            {
                if (!Utils.IsEqual(m_ServerIndex, value.m_ServerIndex)) return false;
            }
            if (!Utils.IsEqual(m_NodeId, value.m_NodeId)) return false;
            if (IsAliasNameSet())
            {
                if (!Utils.IsEqual(m_AliasName, value.m_AliasName)) return false;
            }
            if (IsAliasReferenceTypeFilterSet())
            {
                if (!Utils.IsEqual(m_AliasReferenceTypeFilter, value.m_AliasReferenceTypeFilter)) return false;
            }
            if (IsRelativePathSet())
            {
                if (!Utils.IsEqual(m_RelativePath, value.m_RelativePath)) return false;
            }

            return true;
        }

        /// <summary>
        /// Clones this instance.
        /// </summary>
        /// <returns>System.Object.</returns>
        public virtual object Clone()
        {
            eUAClientRemoteVariableDescriptor clone = (eUAClientRemoteVariableDescriptor)this.MemberwiseClone();

            clone.m_encodingMask = m_encodingMask;
            clone.m_DiscoveryEndpoint = (string)Utils.Clone(this.m_DiscoveryEndpoint);
            clone.m_ServerIndex = (short)Utils.Clone(this.m_ServerIndex);
            clone.m_NodeId = (NodeId)Utils.Clone(this.m_NodeId);
            clone.m_AliasName = (string)Utils.Clone(this.m_AliasName);
            clone.m_AliasReferenceTypeFilter = (NodeId)Utils.Clone(this.m_AliasReferenceTypeFilter);
            clone.m_RelativePath = (RelativePathElementCollection)Utils.Clone(this.m_RelativePath);

            return clone;
        }
        #endregion

        #region Private Fields
        protected uint m_encodingMask;
        private string m_DiscoveryEndpoint;
        private short? m_ServerIndex;
        private NodeId m_NodeId;
        private string m_AliasName;
        private NodeId m_AliasReferenceTypeFilter;
        private RelativePathElementCollection m_RelativePath;
        #endregion
    }

    #region eUAClientRemoteVariableDescriptorCollection class
    /// <summary>
    /// A collection of eUAClientRemoteVariableDescriptor objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfeUAClientRemoteVariableDescriptor", Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClient, ItemName = "eUAClientRemoteVariableDescriptor")]
    public partial class eUAClientRemoteVariableDescriptorCollection : List<eUAClientRemoteVariableDescriptor>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public eUAClientRemoteVariableDescriptorCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new list can initially store.</param>
        public eUAClientRemoteVariableDescriptorCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        /// <param name="collection">The collection whose elements are copied to the new list.</param>
        public eUAClientRemoteVariableDescriptorCollection(IEnumerable<eUAClientRemoteVariableDescriptor> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator eUAClientRemoteVariableDescriptorCollection(eUAClientRemoteVariableDescriptor[] values)
        {
            if (values != null)
            {
                return new eUAClientRemoteVariableDescriptorCollection(values);
            }

            return new eUAClientRemoteVariableDescriptorCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator eUAClientRemoteVariableDescriptor[](eUAClientRemoteVariableDescriptorCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <returns>A new object that is a copy of this instance.</returns>
        public object Clone()
        {
            eUAClientRemoteVariableDescriptorCollection clone = new eUAClientRemoteVariableDescriptorCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((eUAClientRemoteVariableDescriptor)Utils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region eUAClientServerConnection Class
    /// <summary>
    /// Class eUAClientServerConnection.
    /// Implements the <see cref="IEncodeable" />
    /// </summary>
    /// <seealso cref="IEncodeable" />
    [DataContract(Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClientXsd)]
    public partial class eUAClientServerConnection : IEncodeable
    {
        #region Optional Members
        /// <summary>
        /// Enum eUAClientServerConnectionSet
        /// </summary>
        [Flags]
        private enum eUAClientServerConnectionSet
        {
            /// <summary>
            /// The user name
            /// </summary>
            UserName = 1,
            /// <summary>
            /// The password
            /// </summary>
            Password = 2,
            /// <summary>
            /// The certificate data
            /// </summary>
            CertificateData = 4,
            /// <summary>
            /// The token data
            /// </summary>
            TokenData = 8,
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="eUAClientServerConnection"/> class.
        /// </summary>
        public eUAClientServerConnection()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_encodingMask = 0;
            m_Endpoint = null;
            m_UserTokenType = UserTokenType.Anonymous;
            m_UserName = null;
            m_Password = null;
            m_CertificateData = null;
            m_TokenData = null;
        }
        #endregion

        #region Public Properties
        [DataMember(Name = "EncodingMask", IsRequired = false, Order = 1)]
        private uint EncodingMask
        {
            get
            {
                return m_encodingMask;
            }
            set
            {
                m_encodingMask = value;
            }
        }

        /// <summary>
        /// Gets or sets the endpoint.
        /// </summary>
        /// <value>The endpoint.</value>
        [DataMember(Name = "Endpoint", IsRequired = false, Order = 2)]
        public EndpointType Endpoint
        {
            get
            {
                return m_Endpoint;
            }
            set
            {
                m_Endpoint = value;
            }
        }
        /// <summary>
        /// Gets or sets the type of the user token.
        /// </summary>
        /// <value>The type of the user token.</value>
        [DataMember(Name = "UserTokenType", IsRequired = false, Order = 3)]
        public UserTokenType UserTokenType
        {
            get
            {
                return m_UserTokenType;
            }
            set
            {
                m_UserTokenType = value;
            }
        }
        /// <summary>
        /// Gets or sets the name of the user.
        /// </summary>
        /// <value>The name of the user.</value>
        [DataMember(Name = "UserName", IsRequired = false, Order = 4)]
        public string UserName
        {
            get
            {
                return m_UserName;
            }
            set
            {
                m_UserName = value;
                m_encodingMask |= (uint)eUAClientServerConnectionSet.UserName;
            }
        }
        /// <summary>
        /// Gets or sets the password.
        /// </summary>
        /// <value>The password.</value>
        [DataMember(Name = "Password", IsRequired = false, Order = 5)]
        public string Password
        {
            get
            {
                return m_Password;
            }
            set
            {
                m_Password = value;
                m_encodingMask |= (uint)eUAClientServerConnectionSet.Password;
            }
        }
        /// <summary>
        /// Gets or sets the certificate data.
        /// </summary>
        /// <value>The certificate data.</value>
        [DataMember(Name = "CertificateData", IsRequired = false, Order = 6)]
        public byte[] CertificateData
        {
            get
            {
                return m_CertificateData;
            }
            set
            {
                m_CertificateData = value;
                m_encodingMask |= (uint)eUAClientServerConnectionSet.CertificateData;
            }
        }
        /// <summary>
        /// Gets or sets the token data.
        /// </summary>
        /// <value>The token data.</value>
        [DataMember(Name = "TokenData", IsRequired = false, Order = 7)]
        public byte[] TokenData
        {
            get
            {
                return m_TokenData;
            }
            set
            {
                m_TokenData = value;
                m_encodingMask |= (uint)eUAClientServerConnectionSet.TokenData;
            }
        }

        /// <summary>
        /// Determines whether [is user name set].
        /// </summary>
        /// <returns><c>true</c> if [is user name set]; otherwise, <c>false</c>.</returns>
        public bool IsUserNameSet()
        {
            return (m_encodingMask & (uint)eUAClientServerConnectionSet.UserName) != 0;
        }

        /// <summary>
        /// Unsets the name of the user.
        /// </summary>
        public void UnsetUserName()
        {
            m_encodingMask &= (~((uint)eUAClientServerConnectionSet.UserName));
            m_UserName = null;
        }

        /// <summary>
        /// Determines whether [is password set].
        /// </summary>
        /// <returns><c>true</c> if [is password set]; otherwise, <c>false</c>.</returns>
        public bool IsPasswordSet()
        {
            return (m_encodingMask & (uint)eUAClientServerConnectionSet.Password) != 0;
        }

        /// <summary>
        /// Unsets the password.
        /// </summary>
        public void UnsetPassword()
        {
            m_encodingMask &= (~((uint)eUAClientServerConnectionSet.Password));
            m_Password = null;
        }

        /// <summary>
        /// Determines whether [is certificate data set].
        /// </summary>
        /// <returns><c>true</c> if [is certificate data set]; otherwise, <c>false</c>.</returns>
        public bool IsCertificateDataSet()
        {
            return (m_encodingMask & (uint)eUAClientServerConnectionSet.CertificateData) != 0;
        }

        /// <summary>
        /// Unsets the certificate data.
        /// </summary>
        public void UnsetCertificateData()
        {
            m_encodingMask &= (~((uint)eUAClientServerConnectionSet.CertificateData));
            m_CertificateData = null;
        }

        /// <summary>
        /// Determines whether [is token data set].
        /// </summary>
        /// <returns><c>true</c> if [is token data set]; otherwise, <c>false</c>.</returns>
        public bool IsTokenDataSet()
        {
            return (m_encodingMask & (uint)eUAClientServerConnectionSet.TokenData) != 0;
        }

        /// <summary>
        /// Unsets the token data.
        /// </summary>
        public void UnsetTokenData()
        {
            m_encodingMask &= (~((uint)eUAClientServerConnectionSet.TokenData));
            m_TokenData = null;
        }
        #endregion

        #region IEncodeable Members
        /// <inheritdoc />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.eUAClientServerConnection; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.eUAClientServerConnection_Encoding_DefaultBinary; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.eUAClientServerConnection_Encoding_DefaultXml; }
        }

        /// <inheritdoc />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.UAClientXsd);

            encoder.WriteUInt32("EncodingMask", (uint)m_encodingMask);

            encoder.WriteEncodeable("Endpoint", Endpoint, typeof(EndpointType));
            encoder.WriteEnumerated("UserTokenType", UserTokenType);
            if (IsUserNameSet())
            {
                encoder.WriteString("UserName", UserName);
            }
            if (IsPasswordSet())
            {
                encoder.WriteString("Password", Password);
            }
            if (IsCertificateDataSet())
            {
                encoder.WriteByteString("CertificateData", CertificateData);
            }
            if (IsTokenDataSet())
            {
                encoder.WriteByteString("TokenData", TokenData);
            }

            encoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.UAClientXsd);

            m_encodingMask = decoder.ReadUInt32("EncodingMask");

            Endpoint = (EndpointType)decoder.ReadEncodeable("Endpoint", typeof(EndpointType));
            UserTokenType = (UserTokenType)decoder.ReadEnumerated("UserTokenType", typeof(UserTokenType));
            if (IsUserNameSet())
            {
                UserName = decoder.ReadString("UserName");
            }
            if (IsPasswordSet())
            {
                Password = decoder.ReadString("Password");
            }
            if (IsCertificateDataSet())
            {
                CertificateData = decoder.ReadByteString("CertificateData");
            }
            if (IsTokenDataSet())
            {
                TokenData = decoder.ReadByteString("TokenData");
            }

            decoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            eUAClientServerConnection value = encodeable as eUAClientServerConnection;

            if (value == null)
            {
                return false;
            }
            if (m_encodingMask != value.m_encodingMask) return false;
            if (!Utils.IsEqual(m_Endpoint, value.m_Endpoint)) return false;
            if (!Utils.IsEqual(m_UserTokenType, value.m_UserTokenType)) return false;
            if (IsUserNameSet())
            {
                if (!Utils.IsEqual(m_UserName, value.m_UserName)) return false;
            }
            if (IsPasswordSet())
            {
                if (!Utils.IsEqual(m_Password, value.m_Password)) return false;
            }
            if (IsCertificateDataSet())
            {
                if (!Utils.IsEqual(m_CertificateData, value.m_CertificateData)) return false;
            }
            if (IsTokenDataSet())
            {
                if (!Utils.IsEqual(m_TokenData, value.m_TokenData)) return false;
            }

            return true;
        }

        /// <summary>
        /// Clones this instance.
        /// </summary>
        /// <returns>System.Object.</returns>
        public virtual object Clone()
        {
            eUAClientServerConnection clone = (eUAClientServerConnection)this.MemberwiseClone();

            clone.m_encodingMask = m_encodingMask;
            clone.m_Endpoint = (EndpointType)Utils.Clone(this.m_Endpoint);
            clone.m_UserTokenType = (UserTokenType)Utils.Clone(this.m_UserTokenType);
            clone.m_UserName = (string)Utils.Clone(this.m_UserName);
            clone.m_Password = (string)Utils.Clone(this.m_Password);
            clone.m_CertificateData = (byte[])Utils.Clone(this.m_CertificateData);
            clone.m_TokenData = (byte[])Utils.Clone(this.m_TokenData);

            return clone;
        }
        #endregion

        #region Private Fields
        protected uint m_encodingMask;
        private EndpointType m_Endpoint;
        private UserTokenType m_UserTokenType;
        private string m_UserName;
        private string m_Password;
        private byte[] m_CertificateData;
        private byte[] m_TokenData;
        #endregion
    }

    #region eUAClientServerConnectionCollection class
    /// <summary>
    /// A collection of eUAClientServerConnection objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfeUAClientServerConnection", Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClient, ItemName = "eUAClientServerConnection")]
    public partial class eUAClientServerConnectionCollection : List<eUAClientServerConnection>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public eUAClientServerConnectionCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new list can initially store.</param>
        public eUAClientServerConnectionCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        /// <param name="collection">The collection whose elements are copied to the new list.</param>
        public eUAClientServerConnectionCollection(IEnumerable<eUAClientServerConnection> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator eUAClientServerConnectionCollection(eUAClientServerConnection[] values)
        {
            if (values != null)
            {
                return new eUAClientServerConnectionCollection(values);
            }

            return new eUAClientServerConnectionCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator eUAClientServerConnection[](eUAClientServerConnectionCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <returns>A new object that is a copy of this instance.</returns>
        public object Clone()
        {
            eUAClientServerConnectionCollection clone = new eUAClientServerConnectionCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((eUAClientServerConnection)Utils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region eUAClientVariableGroup Class
    /// <summary>
    /// Class eUAClientVariableGroup.
    /// Implements the <see cref="IEncodeable" />
    /// </summary>
    /// <seealso cref="IEncodeable" />
    [DataContract(Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClientXsd)]
    public partial class eUAClientVariableGroup : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="eUAClientVariableGroup"/> class.
        /// </summary>
        public eUAClientVariableGroup()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_GroupType = eUAClientGroupType.Subscribe;
            m_CycleTime = 0.0;
            m_NodeMappings = new eUAClientNodeMappingCollection();
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the type of the group.
        /// </summary>
        /// <value>The type of the group.</value>
        [DataMember(Name = "GroupType", IsRequired = false, Order = 1)]
        public eUAClientGroupType GroupType
        {
            get
            {
                return m_GroupType;
            }
            set
            {
                m_GroupType = value;
            }
        }
        /// <summary>
        /// Gets or sets the cycle time.
        /// </summary>
        /// <value>The cycle time.</value>
        [DataMember(Name = "CycleTime", IsRequired = false, Order = 2)]
        public double CycleTime
        {
            get
            {
                return m_CycleTime;
            }
            set
            {
                m_CycleTime = value;
            }
        }
        /// <summary>
        /// Gets or sets the node mappings.
        /// </summary>
        /// <value>The node mappings.</value>
        [DataMember(Name = "NodeMappings", IsRequired = false, Order = 3)]
        public eUAClientNodeMappingCollection NodeMappings
        {
            get
            {
                return m_NodeMappings;
            }
            set
            {
                m_NodeMappings = value;

                if (value == null)
                {
                    m_NodeMappings = new eUAClientNodeMappingCollection();
                }
            }
        }
        #endregion

        #region IEncodeable Members
        /// <inheritdoc />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.eUAClientVariableGroup; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.eUAClientVariableGroup_Encoding_DefaultBinary; }
        }

        /// <inheritdoc />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.eUAClientVariableGroup_Encoding_DefaultXml; }
        }

        /// <inheritdoc />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.UAClientXsd);

            encoder.WriteEnumerated("GroupType", GroupType);
            encoder.WriteDouble("CycleTime", CycleTime);
            encoder.WriteEncodeableArray("NodeMappings", NodeMappings.ToArray(), typeof(eUAClientNodeMapping));

            encoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.UAClientXsd);
            GroupType = (eUAClientGroupType)decoder.ReadEnumerated("GroupType", typeof(eUAClientGroupType));
            CycleTime = decoder.ReadDouble("CycleTime");
            NodeMappings = (eUAClientNodeMappingCollection)decoder.ReadEncodeableArray("NodeMappings", typeof(eUAClientNodeMapping));

            decoder.PopNamespace();
        }

        /// <inheritdoc />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            eUAClientVariableGroup value = encodeable as eUAClientVariableGroup;

            if (value == null)
            {
                return false;
            }
            if (!Utils.IsEqual(m_GroupType, value.m_GroupType)) return false;
            if (!Utils.IsEqual(m_CycleTime, value.m_CycleTime)) return false;
            if (!Utils.IsEqual(m_NodeMappings, value.m_NodeMappings)) return false;

            return true;
        }

        /// <summary>
        /// Clones this instance.
        /// </summary>
        /// <returns>System.Object.</returns>
        public virtual object Clone()
        {
            eUAClientVariableGroup clone = (eUAClientVariableGroup)this.MemberwiseClone();

            clone.m_GroupType = (eUAClientGroupType)Utils.Clone(this.m_GroupType);
            clone.m_CycleTime = (double)Utils.Clone(this.m_CycleTime);
            clone.m_NodeMappings = (eUAClientNodeMappingCollection)Utils.Clone(this.m_NodeMappings);

            return clone;
        }
        #endregion

        #region Private Fields
        private eUAClientGroupType m_GroupType;
        private double m_CycleTime;
        private eUAClientNodeMappingCollection m_NodeMappings;
        #endregion
    }

    #region eUAClientVariableGroupCollection class
    /// <summary>
    /// A collection of eUAClientVariableGroup objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfeUAClientVariableGroup", Namespace = Arp.OpcUA.ClientConfiguration.Namespaces.UAClient, ItemName = "eUAClientVariableGroup")]
    public partial class eUAClientVariableGroupCollection : List<eUAClientVariableGroup>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public eUAClientVariableGroupCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new list can initially store.</param>
        public eUAClientVariableGroupCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        /// <param name="collection">The collection whose elements are copied to the new list.</param>
        public eUAClientVariableGroupCollection(IEnumerable<eUAClientVariableGroup> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator eUAClientVariableGroupCollection(eUAClientVariableGroup[] values)
        {
            if (values != null)
            {
                return new eUAClientVariableGroupCollection(values);
            }

            return new eUAClientVariableGroupCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator eUAClientVariableGroup[](eUAClientVariableGroupCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <returns>A new object that is a copy of this instance.</returns>
        public object Clone()
        {
            eUAClientVariableGroupCollection clone = new eUAClientVariableGroupCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((eUAClientVariableGroup)Utils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion


    #region EncodeableTypes
    /// <summary>
    /// Contains a method for registering all encodeable types of the namespace.
    /// </summary>
    public class EncodeableTypes
    {
        /// <summary>
        /// Register all encodeable types of the namespace at the communication stack.
        /// The Decoder will decode the registered types.
        /// </summary>
        /// <param name="context">The context.</param>
        public static void RegisterEncodeableTypes(ServiceMessageContext context)
        {
            context.Factory.AddEncodeableType(typeof(Arp.OpcUA.ClientConfiguration.eUAClientConfiguration));
            context.Factory.AddEncodeableType(typeof(Arp.OpcUA.ClientConfiguration.eUAClientNodeMapping));
            context.Factory.AddEncodeableType(typeof(Arp.OpcUA.ClientConfiguration.eUAClientRemoteVariableDescriptor));
            context.Factory.AddEncodeableType(typeof(Arp.OpcUA.ClientConfiguration.eUAClientServerConnection));
            context.Factory.AddEncodeableType(typeof(Arp.OpcUA.ClientConfiguration.eUAClientVariableGroup));
        }
    }
    #endregion
}
